Определим f(x) для положительного числа x как длину десятичного представления x без лидирующих нулей. Мне нравится называть это цифровым логарифмом. Похоже на цифровой корень, если вы с таким знакомы.

Даны два массива a и b, каждый содержит по n целых положительных чисел. За одну операцию вы можете сделать следующее:

выбрать целое число i от 1 до n;
присвоить либо f(ai) вместо ai, либо f(bi) вместо bi.
Два массива называются похожими друг на друга, если можно переупорядочить элементы в них обоих так, чтобы они стали равны (т. е. ai=bi для всех i от 1 до n).

Какое наименьшее количество операций надо сделать, чтобы a и b стали похожими друг на друга?

Входные данные
В первой строке записано одно целое число t (1≤t≤104) — количество наборов входных данных.

В первой строке каждого набора входных данных записано одно целое число n (1≤n≤2⋅105) — количество элементов в каждом из массивов.

Во второй строке записаны n целых чисел a1,a2,…,an (1≤ai<109).

В третьей строке записаны n целых чисел b1,b2,…,bn (1≤bj<109).

Сумма n по всем наборам входных данных не превосходит 2⋅105.

Выходные данные
На каждый набор входных данных выведите наименьшее количество операций, которые надо сделать, чтобы a и b стали похожими друг на друга.